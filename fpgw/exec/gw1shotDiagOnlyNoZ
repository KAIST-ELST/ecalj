#!/bin/bash 
# ---------------------------------------------------------
# QP self-consistent GW itteration using MPI. Using run_arg
### you may need to set echo_run and serial_run in /run_arg for cray machine
# ---------------------------------------------------------

if [ $# -ne 3 ] || [ $1 != "-np" ] ; then
    echo "An example of usage: gwsc1shotDiagOnlyNoZ -np 4 si"
    exit 101
fi
n=$0
nfpgw=`dirname $0`
TARGET=$3
MPI_SIZE=$2
NO_MPI=0
lx0_para_option=""  #set lx0_para_option='-nq 4 -ns 1'

### Read funcitons run_arg and run_arg_tee defined in a file run_arg ###
source $nfpgw/run_arg #define echo_run and serial_run in run_arg

$echo_run echo "### START gwsc1shotDiagOnlyNoZ: MPI size= " $MPI_SIZE, "TARGET= "$TARGET

##### rm and mkdir ##############
if [ -e NoCore ]; then #backword compatibility not so meaningful now.
  rm -f NoCore 
fi
if [ -e QPU ]; then
 rm -f QP[UD]
fi
if [ ! -e SEBK ]; then
 mkdir SEBK
fi
## mv sigm or simg.$TARGET to sigm. And make softlink to simg.$TARGET.
## sigm is prior to simg.$TARGET.
if [ -e sigm ]; then
  if [ -e sigm.$TARGET ]; then
    mv sigm.$TARGET sigm.$TARGET.bakup 
    ln -s -f sigm sigm.$TARGET 
    $echo_run echo '--- sigm is used. sigm.$TARGET is softlink to it  ---'
  fi
else
  if [ -e sigm.$TARGET ]; then
    mv sigm.$TARGET sigm
    ln -s -f sigm sigm.$TARGET 
    $echo_run echo '--- sigm.$TARGET is moved to sigm. sigm.$TARGET is softlink now.  ---'
  else
    $echo_run echo '--- No sigm nor sigm.$TARGET files for starting ---'
  fi
fi 

##### itteration loop start ##########################################
for ix in 0 1
do
 ##### self-consistent calculation for given Sigma(self-energy ###
 $echo_run echo " ---- goto sc calculation for given sigma-vxc --- ix=",$ix
 if [ $ix == 0 ]; then # ix=0 is for iteration from LDA.
  if [ -e sigm.$TARGET ] ; then
    $echo_run echo " we have sigm already, skip iter=0"
  fi   
  $echo_run echo "No sigm ---> LDA caculation for eigenfunctions "
  rm -f llmf
  run_arg '---' $MPI_SIZE $nfpgw          /lmf-MPIK llmf_lda $TARGET
  cp rst.$TARGET rst.$TARGET.lda
 else
  run_arg '---' $MPI_SIZE $nfpgw          /lmf-MPIK llmf $TARGET
 fi
 rm -f ewindow.${TARGET}* qbyl.${TARGET}* eigze*.${TARGET}*
 argin=0; run_arg $argin $NO_MPI  $nfpgw  /lmfgw  llmfgw00 $TARGET 
 argin=1; run_arg $argin $NO_MPI  $nfpgw  /qg4gw lqg4gw   #Generate requied q+G v

 ### eigenvalues for micro-tetrahedron method. Rarely used.
 if [ -e Qmtet ]; then
  mv Qmtet Qeigval 
  argin=5; run_arg $argin $MPI_SIZE $nfpgw /lmfgw-MPIK llmfgw_eigval $TARGET
  mv eigval eigmtet
 fi
 argin=1; run_arg $argin $MPI_SIZE $nfpgw /lmfgw-MPIK llmfgw01 $TARGET
 run_arg  '---' $NO_MPI   $nfpgw /lmf2gw     llmf2gw  #reform data for gw

 ##### main stage of gw ################
 argin=0; run_arg $argin $NO_MPI   $nfpgw /rdata4gw_v2 lrdata4gw_v2 #prepare files
 if [ $ix == 0 ]; then 
   cp evec.$TARGET evec0  # used in hqpe_sc for isigma_en==5
 fi
 if [ -e ANFcond ]; then
   cp EVU EVD  # This is for ANFcond. Rarely used recently
 fi
 argin=1; run_arg $argin $NO_MPI $nfpgw   /heftet leftet # A file EFERMI for hx0fp0
 argin=1; run_arg $argin $NO_MPI $nfpgw   /hchknw lchknw # A file NW, containing nw 
 ### Core part of the self-energy (exchange only) ###
 argin=3; run_arg $argin $NO_MPI $nfpgw   /hbasfp0 lbasC  # Product basis generation 
 argin=3; run_arg $argin $MPI_SIZE $nfpgw /hvccfp0 lvccC # Coulomb matrix for lbasC 
 argin=1003; run_arg $argin $MPI_SIZE $nfpgw /hsfp0_sc lsxC # Sigma from core1
 ### Valence part of the self-energy Sigma ###
 argin=0; run_arg $argin $NO_MPI $nfpgw   /hbasfp0 lbas # Product basis generation 
 argin=0; run_arg $argin $MPI_SIZE $nfpgw /hvccfp0 lvcc # Coulomb matrix for lbas 
 argin=1001; run_arg $argin $MPI_SIZE $nfpgw /hsfp0_sc lsx # Exchange Sigma
  if [ -e WV.d ]; then
    rm -f WV* 
  fi
 # following two runs are most expensive #
 argin=11; run_arg $argin $MPI_SIZE $nfpgw /hx0fp0_sc lx0 $lx0_para_option #x0 part
 argin=1002;  run_arg $argin $MPI_SIZE $nfpgw /hsfp0_sc lsc #correlation Sigma
 argin=1000;  run_arg $argin $NO_MPI $nfpgw   /hqpe lqpe #all Sigma are combined.
 mv QPU QPU.noZ
 if [ -e QPD ]; then
   mv QPD QPD.noZ  # This is for ANFcond. Rarely used recently
 fi
 $echo_run echo ==== ' end of 1shot diagonly ======== '
 exit
done 
